#define _XOPEN_SOURCE_EXTENDED
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "cutest_conf.h"

#define TMP_EXE_TEMPLATE "tmpXXXXXX"
#define TMP_SRC_TEMPLATE "tmpXXXXXX.c"

const char* cc_std_map[STD_NONE] = {"-std=c90",
                                    "-std=c99",
                                    "-std=c11"};

const char* cc_capability_map[CC_NONE] = {"-pedantic",
                                          "-fvisibility=hidden",
                                          "-fprofile-arcs -ftest-coverage",
                                          "-Wextra",
                                          "-Wno-pragmas",
                                          "-flto",
                                          "-DVARIADIC=1"};

static void usage(const char* program_name)
{
  printf("USAGE: %s <src-path> <test-path> <bin-path> <inc-path>\n"
         "\n"
         " src-path  where your design source files are locaed.\n"
         " test-path where your have your test-suites.\n"
         " bin-path  where your cutest binaries are installed.\n"
         " inc-path  where your cutest header files are installed.\n"
         "\n",
         program_name);
}

static int cc_have_option(const char* option, const char* tmpdst,
                          const char* tmpsrc)
{
  char command[1024];
  sprintf(command, "$CC %s -o %s %s 2>&1 >/dev/null",
          option, tmpdst, tmpsrc);
  const int retval = system(command);
  if (EXIT_SUCCESS == retval) {
    return 1;
  }
  return 0;
}

static char* generate_tmp_executable_filename()
{
  const size_t len = strlen(TMP_EXE_TEMPLATE) + 1;
  char* filename = malloc(len);
  if (NULL == filename) {
    fprintf(stderr, "ERROR: Out of memory while allocating temporary "
            "executable filename\n");
    return NULL;
  }
  memcpy(filename, TMP_EXE_TEMPLATE, len);
  filename[len - 1] = 0;
  mkstemp(filename);
  return filename;
}

static char* generate_tmp_source_filename(const char *executable)
{
  const size_t len = strlen(executable) + 2 + 1;
  char* filename = malloc(len);
  if (NULL == filename) {
    fprintf(stderr, "ERROR: Out of memory while allocating temporary "
            "source filename\n");
    return NULL;
  }
  memcpy(filename, executable, len - 2);
  filename[len - 3] = '.';
  filename[len - 2] = 'c';
  filename[len - 1] = 0;

  return filename;
}

static int generate_tmp_program_for_cc_evaluation(const char* tmpsrc)
{
  FILE *fd = fopen(tmpsrc, "w");
  if (NULL == fd) {
    return 0;
  }
  fputs("/*\n"
        " * Generated program to evaluate various C compiler features\n"
        " */\n"
        "\n"
        "#include \"cutest.h\"\n"
        "\n"
        "int main(int argc, char* argv[]) {\n"
        "  (void)argc;\n"
        "  (void)argv;\n"
        "  return 0;\n"
        "}", fd);
  fflush(fd);
  fclose(fd);
  return 1;
}

static const char* cc_std2str(cc_std_t std)
{
  if (STD_NONE == std) {
    return "";
  }
  return cc_std_map[std];
}

static const char* cc_capability2str(cc_capability_t capability, int lookup)
{
  if (lookup) {
    return cc_capability_map[capability];
  }
  return "";
}

static cc_std_t get_cc_std(const char* tmpdst, const char* tmpsrc)
{
  if (cc_have_option(cc_std2str(STD_GCC_C11), tmpdst, tmpsrc)) {
    return STD_GCC_C11;
  }
  if (cc_have_option(cc_std2str(STD_GCC_C99), tmpdst, tmpsrc)) {
    return STD_GCC_C99;
  }
  if (cc_have_option(cc_std2str(STD_GCC_C90), tmpdst, tmpsrc)) {
    return STD_GCC_C90;
  }
  return STD_NONE;
}

static void get_cc_capabilities(cc_capabilities_t* capabilities,
                                const char* tmpdst, const char* tmpsrc)
{
  cc_capabilities_t* c = capabilities;
  c->pedantic =
    cc_have_option(cc_capability2str(CC_GCC_PEDANTIC, 1),
                   tmpdst, tmpsrc);
  c->visibility_hidden =
    cc_have_option(cc_capability2str(CC_GCC_VISIBILITY_HIDDEN, 1),
                   tmpdst, tmpsrc);
  c->test_coverage =
    cc_have_option(cc_capability2str(CC_GCC_TEST_COVERAGE, 1),
                   tmpdst, tmpsrc);
  c->extra =
    cc_have_option(cc_capability2str(CC_GCC_EXTRA, 1),
                   tmpdst, tmpsrc);
  c->no_pragmas =
    cc_have_option(cc_capability2str(CC_GCC_NO_PRAGMAS, 1),
                   tmpdst, tmpsrc);
  c->lto =
    cc_have_option(cc_capability2str(CC_GCC_LTO, 1),
                   tmpdst, tmpsrc);
  c->variadic_macros =
    cc_have_option(cc_capability2str(CC_GCC_VARIADIC_MACROS, 1),
                   tmpdst, tmpsrc);
}

static void print_head(const char* program_name)
{
  printf("/*\n"
         " * This file is generated by %s to give fast access to your\n"
         " * compiler's capabilities to ensure as fast builds of your\n"
         " * test-suites\n"
         " */\n"
         "\n"
         "#ifndef _CUTEST_CONFIGURATION_H_\n"
         "#define _CUTEST_CONFIGURATION_H_\n"
         "\n"
         "#define CUTEST_CONFIGURATION_VERSION 0\n"
         "\n",
         program_name);
}

static void print_cc_capabilities(cc_capabilities_t* capabilities,
                                  cc_std_t cc_std)
{
  cc_capabilities_t* c = capabilities;
  printf("#define CUTEST_CC_STD \"%s\"\n"
         "#define CUTEST_CC_PEDANTIC \"%s\"\n"
         "#define CUTEST_CC_VISIBILITY_HIDDEN \"%s\"\n"
         "#define CUTEST_CC_TEST_COVERAGE \"%s\"\n"
         "#define CUTEST_CC_EXTRA \"%s\"\n"
         "#define CUTEST_CC_NO_PRAGMA \"%s\"\n"
         "#define CUTEST_CC_LTO \"%s\"\n"
         "#define CUTEST_CC_VARIADIC_MACROS \"%s\"\n"
         "\n",
         cc_std2str(cc_std),
         cc_capability2str(CC_GCC_PEDANTIC, c->pedantic),
         cc_capability2str(CC_GCC_VISIBILITY_HIDDEN, c->visibility_hidden),
         cc_capability2str(CC_GCC_TEST_COVERAGE, c->test_coverage),
         cc_capability2str(CC_GCC_EXTRA, c->extra),
         cc_capability2str(CC_GCC_NO_PRAGMAS, c->no_pragmas),
         cc_capability2str(CC_GCC_LTO, c->lto),
         cc_capability2str(CC_GCC_VARIADIC_MACROS, c->variadic_macros));
}

static void print_paths(const char* src_path, const char* test_path,
                        const char* bin_path, const char* inc_path)
{
  printf("#define CUTEST_SRC_PATH \"%s\"\n"
         "#define CUTEST_TST_PATH \"%s\"\n"
         "#define CUTEST_BIN_PATH \"%s\"\n"
         "#define CUTEST_INC_PATH \"%s\"\n",
         src_path,
         test_path,
         bin_path,
         inc_path);
}

static void print_footer()
{
  printf("\n"
         "#endif\n");
}

int main(int argc, char* argv[])
{
  (void)argc;
  (void)argv;
  cc_capabilities_t cc_capabilities;
  char *tmpdst;
  char *tmpsrc;
  cc_std_t cc_std = STD_NONE;
  const char* program_name = argv[0];
  const char* src_path = argv[1];
  const char* test_path = argv[2];
  const char* bin_path = argv[3];
  const char* inc_path = argv[4];

  if (argc < 5) {
    fprintf(stderr, "ERROR: Too few arguments provided\n");
    usage(program_name);
    return EXIT_FAILURE;
  }

  tmpdst = generate_tmp_executable_filename();
  tmpsrc = generate_tmp_source_filename(tmpdst);

  if (0 == generate_tmp_program_for_cc_evaluation(tmpsrc)) {
    fprintf(stderr, "ERROR: Could not generate temporary program for CC "
            "evalation\n");
    return EXIT_FAILURE;
  }

  cc_std = get_cc_std(tmpdst, tmpsrc);
  get_cc_capabilities(&cc_capabilities, tmpdst, tmpsrc);

  print_head(program_name);
  print_cc_capabilities(&cc_capabilities, cc_std);
  print_paths(src_path, test_path, bin_path, inc_path);
  print_footer();

  remove(tmpdst);
  remove(tmpsrc);

  free(tmpdst);
  free(tmpsrc);

  return EXIT_SUCCESS;
}
