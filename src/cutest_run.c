/*********************************************************************
   ------    ____ ____ _____ ____ ____ _____   ____ ____ _ __ --------
   ------   / __// / //_  _// __// __//_  _/  / _ // / //|/ / -------
   ------  / /_ / / /  / / / __//_  /  / /   /   |/ / //   /  -------
   ------ /___//___/  /_/ /___//___/  /_/   /_/_//___//_|_/   -------
 *
 * CUTest test runner generator
 * ============================
 *
 * The ``cutest_run`` tool will parse your test suite and produce an
 * executable program with some command line options to enable you to
 * control it a little bit.
 *
 * How to build the tool
 * ---------------------
 *
 * Just include the ``cutest.mk`` makefile in your own ``Makefile`` in
 * your folder containing the source code for the ``*_test.c`` files.
 *
 * The tool is automatically compiled when making the check target.
 * But if you want to make the tool explicitly just call::
 *
 *  $ make cutest_run
 *
 * Usage
 * -----
 *
 * If you *need* to run the tool manually this is how::
 *
 *  $ ./cutest_run dut_test.c dut_mocks.h
 *
 * And it will scan the test suite source-code for uses of the ``test()``
 * and ``module_test()`` macros and output a C program containing
 * everything needed to test your code alongside with the ``cutest.h``
 * file.
 *
 * However, if you use the ``Makefile`` targets specified in the
 * beginning of this document you will probably not need to run it
 * manually.
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define CHUNK_SIZE 1024

#include "testcase.h"
#include "cutest_run.h"
#include "helpers.h"

static void usage(const char* program_name)
{
  printf("USAGE: %s <test-c-source-file> <c-mock-header-file>\n",
         program_name);
}

static void replace_last_parenthesis_with_0(char *buf, int start)
{
  size_t i;
  const size_t len = strlen(buf);

  for (i = start; i < len; i++) {
    if (')' == buf[i]) {
      buf[i] = 0;
      return;
    }
  }
  fprintf(stderr, "ERROR: Malformed test-case '%s'", buf);
}

static int skip_comments(const char* buf)
{
  const size_t len = strlen(buf);
  size_t i;
  int slash_star_comment = 0;

  for (i = 0; i < len - 1; i++) {
    if (('/' == buf[i]) && ('*' == buf[i+1])) {
      slash_star_comment++;
    }
    else if (('*' == buf[i]) && ('/' == buf[i+1])) {
      slash_star_comment--;
    }
  }
  return slash_star_comment;
}

static struct test_s next_test(char* buf)
{
  struct test_s retval = {NULL, 0};
  size_t len;

  if (0 == strncmp(buf, "test(", len=strlen("test("))) {
    replace_last_parenthesis_with_0(buf, len);
    retval.name = &buf[len];
    retval.reset_mocks = 0;
  }
  else if (0 == strncmp(buf, "module_test(", len = strlen("module_test("))) {
    replace_last_parenthesis_with_0(buf, len);
    retval.name = &buf[len];
    retval.reset_mocks = 1;
  }
  return retval;
}

static void print_header(const char* program_name,
                         const char* test_source_file_name,
                         const char* mock_header_file_name)
{
  printf("/*\n"
         " * This file is generated by '%s %s %s'.\n"
         " *\n"
         " * Compile this program to get a test-case executor.\n"
         " *\n"
         " */\n"
         "\n"
         "#define _XOPEN_SOURCE\n"
         "#include <stdlib.h>\n"
         "#include <stdio.h>\n"
         "#include <string.h>\n"
         "\n"
         "#define main MAIN /* To make sure we can test main() */\n"
         "#define inline\n"
         "#include \"%s\" /* Mock-up functions and design under test */\n"
         "#include \"%s\" /* Test-cases */\n"
         "#undef inline\n"
         "#undef main\n"
         "\n",
         program_name,
         test_source_file_name,
         mock_header_file_name,
         mock_header_file_name,
         test_source_file_name);
}

static void print_main_function_prologue(const char* test_source_file_name,
                                         const size_t test_cnt)
{
  printf("int main(int argc, char* argv[])\n"
         "{\n"
         "  cutest_junit_report_t junit_report[%lu];\n"
         "  int just_print = cutest_startup(argc, argv, \"%s\", junit_report, %lu);\n\n",
         test_cnt,
         test_source_file_name,
         test_cnt);
}

static void print_test_case_executor(const char* name, size_t idx,
                                     int reset_mocks)
{
  printf("  if (1 == cutest_test_name_argument_given(\"%s\")) {\n"
         "    memset(&cutest_mock, 0, sizeof(cutest_mock));\n"
         "    cutest_execute_test(&junit_report[%lu], cutest_%s, \"%s\", %d, argv[0]);\n"
         "  }\n",
         name, idx, name, name, reset_mocks);
}

static void print_main_function_epilogue(const char* test_source_file_name,
                                         const size_t test_cnt)
{
  printf("  return cutest_shutdown(\"%s\", junit_report, %lu);\n\n"
         "}\n",
         test_source_file_name,
         test_cnt);
}

static size_t parse_test_cases(testcase_list_t* list,
                               const char* test_source_file_name)
{
  size_t test_cnt = 0;
  FILE *fd = fopen(test_source_file_name, "r");
  int still_inside_a_comment = 0;

  while (!feof(fd)) {
    testcase_node_t* node = NULL;
    char buf[CHUNK_SIZE];
    struct test_s t;

    if (NULL == fgets(buf, CHUNK_SIZE, fd)) {
      break;
    }

    still_inside_a_comment += skip_comments(buf);
    if (still_inside_a_comment > 0) {
      continue;
    }

    t = next_test(buf);
    if (NULL == t.name) {
      continue;
    }

    node = new_testcase_node(t.name, t.reset_mocks);
    testcase_list_add_node(list, node);

    test_cnt++;
  }

  fclose(fd);

  return test_cnt;
}

static void print_test_case_executions(testcase_list_t* list)
{
  testcase_node_t* node;
  size_t idx = 0;

  for (node = list->first; NULL != node; node = node->next) {
    print_test_case_executor(node->testcase, idx++, node->reset);
  }
}

static void print_test_names_printer(testcase_list_t* list)
{
  testcase_node_t* node;

  printf("  if (just_print) {\n");
  for (node = list->first; NULL != node; node = node->next) {
    printf("    puts(\"%s\");\n", node->testcase);
  }
  printf("    exit(EXIT_SUCCESS);\n"
         "  }\n");
}

/*
 * The test runner program
 * -----------------------
 *
 * The generated test runner program will inventory all the tests in
 * the specified suite and run them in the order that they appear in
 * the suite.
 *
 * The first thing that happens is the start-up process, then all
 * tests are run in isolation, followed by the Shutdown process.
 */
int main(int argc, char* argv[]) {
  const char* program_name = argv[0];
  const char* test_source_file_name = argv[1];
  const char* mock_header_file_name = argv[2];
  testcase_list_t* list = NULL;
  size_t test_cnt = 0;

  if (argc < 3) {
    fprintf(stderr, "ERROR: Missing arguments\n");
    usage(program_name);
    return EXIT_FAILURE;
  }

  if (!file_exists(test_source_file_name) ||
      !file_exists(mock_header_file_name)) {
    return EXIT_FAILURE;
  }

  list = new_testcase_list();
  if (NULL == list) {
    return EXIT_FAILURE;
  }

  test_cnt = parse_test_cases(list, test_source_file_name);

  print_header(program_name, test_source_file_name, mock_header_file_name);
  print_main_function_prologue(test_source_file_name, test_cnt);
  print_test_names_printer(list);
  print_test_case_executions(list);
  print_main_function_epilogue(test_source_file_name, test_cnt);

  delete_testcase_list(list);

  return EXIT_SUCCESS;
}
